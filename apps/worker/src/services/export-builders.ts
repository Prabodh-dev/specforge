import archiver from "archiver";
import { PrismaClient } from "@prisma/client";

export async function buildExport(prisma: PrismaClient, exportId: string) {
  const exp = await prisma.exportFile.findUnique({
    where: { id: exportId },
    select: { id: true, type: true, projectId: true },
  });
  if (!exp) throw new Error("Export not found");

  const latestText = async (type: any) => {
    const art = await prisma.artifact.findUnique({
      where: { projectId_type: { projectId: exp.projectId, type } },
      select: { id: true },
    });
    if (!art) throw new Error(`Artifact missing: ${type}`);

    const v = await prisma.artifactVersion.findFirst({
      where: { artifactId: art.id },
      orderBy: { version: "desc" },
      select: { contentText: true, contentJson: true, version: true },
    });

    return v;
  };

  if (exp.type === "PRD_MD") {
    const v = await latestText("PRD");
    if (!v?.contentText) throw new Error("No PRD content to export");
    return {
      filename: `prd-v${v.version}.md`,
      contentType: "text/markdown; charset=utf-8",
      body: Buffer.from(v.contentText, "utf-8"),
    };
  }

  if (exp.type === "OPENAPI_JSON") {
    const v = await latestText("OPENAPI");
    if (!v?.contentJson) throw new Error("No OpenAPI JSON to export");
    return {
      filename: `openapi-v${v.version}.json`,
      contentType: "application/json; charset=utf-8",
      body: Buffer.from(JSON.stringify(v.contentJson, null, 2), "utf-8"),
    };
  }

  if (exp.type === "DB_SCHEMA_JSON") {
    const v = await latestText("DB_SCHEMA");
    if (!v?.contentJson) throw new Error("No DB schema JSON to export");
    return {
      filename: `db-schema-v${v.version}.json`,
      contentType: "application/json; charset=utf-8",
      body: Buffer.from(JSON.stringify(v.contentJson, null, 2), "utf-8"),
    };
  }

  // SCAFFOLD_ZIP
  const prd = await latestText("PRD");
  const stories = await latestText("USER_STORIES");

  const zipBuffer: Buffer = await new Promise((resolve, reject) => {
    const archive = archiver("zip", { zlib: { level: 9 } });
    const chunks: Buffer[] = [];

    archive.on("data", (d) => chunks.push(d as Buffer));
    archive.on("warning", (err) => console.warn("[zip warning]", err));
    archive.on("error", reject);
    archive.on("end", () => resolve(Buffer.concat(chunks)));

    archive.append(`# Project Scaffold\n\nGenerated by SpecForge.\n`, {
      name: "README.md",
    });

    if (prd?.contentText)
      archive.append(prd.contentText, { name: "specs/PRD.md" });
    if (stories?.contentText)
      archive.append(stories.contentText, { name: "specs/USER_STORIES.md" });

    archive.append(`src/\n`, { name: "backend/.keep" });
    archive.append(`src/\n`, { name: "frontend/.keep" });

    archive.finalize();
  });

  return {
    filename: `scaffold.zip`,
    contentType: "application/zip",
    body: zipBuffer,
  };
}
